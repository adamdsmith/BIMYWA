---
title: "2015 Myrtle Warblers (Block Island)"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: united
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 250)
knitr::opts_chunk$set(dev="png", 
               dev.args=list(type="cairo"),
               dpi=96,
               message=FALSE, warning=FALSE, echo=FALSE, 
               fig.path="./Rpubs/figs/", 
               cache.path="./Rpubs/cache/")
```

```{r load-data}
# Load in some utility functions
source("./R/utils.R")
# Packages
toLoad = c("ggplot2", "plyr", "lubridate", "dplyr")
instant_pkgs(toLoad); rm(toLoad)

# Setting theme for producing figures
theme_set(theme_bw(base_size = 16))
theme_update(panel.grid.minor = element_blank(),
             panel.grid.major= element_blank(),
             panel.border = element_blank(),
             panel.background= element_blank(),
             axis.line = element_line(color = "black"))

# Load RDS file of detections
mywa_det <- readRDS("./Data/2015_BIMYWA_globaltags.rds")

# Load MYWA experimental data
mywa_dat <- read.csv("./Data/mywa_experiment.csv", header = TRUE, stringsAsFactors = FALSE)

# Load antenna orientation data
antennas <- read.csv("./Data/antennas.csv", header = TRUE)
```

```{r filter-data}
# Change format of some MYWA experimental data
mywa_dat <- mywa_dat %>%
  mutate(rel_ts = mdy_hms(paste(rel_date, paste0(rel_time, ":00"))),
         rel_date = mdy(rel_date))

# Simplify detection data 
mywa_det <- mywa_det %>% 
  filter(ts > mdy())
              select(id, ts, site, ant, dbm, sig, lat, lon, runID, runLen, posInRun) %>%
              filter(ts > mdy("09162014")) %>% 
              mutate(r_site = ifelse(site == "BLOCKI-1" | 
                                   site == "BLOCKI-2", "nBLOCKI", site),
                     long = lon,
                     date = ymd(Left(ts, 10)),
                     ts = ymd_hms(as.character(ts)),
                     dbm = round(dbm, 1)) %>%
              tbl_df() 

# For whatever reason, lat and lon are missing from SACH tower
# Add these here
merlins <- mutate(merlins, 
                  lat = ifelse(site == "SACH", 41.4787, lat),
                  long = ifelse(site == "SACH", -71.24376, long),
                  lon = NULL)

# It looks like there was some aliasing of Pam's tags with a couple of ours.  
# In other words, some of her tags can very closely replicate ours for short 
# periods of time.  Thus, the merlins data set must be given a "sanity-check",
# as John B calls it.  Our sanity check is in the form of a deployment record 
# that truncates tag histories prior to their actual date and time of deployment.

# Load this deployment file
deployed <- convert.magic(read.csv("./Data/2014_MERL_deployments.csv", header=TRUE),
                          types = c("character", "integer", "character",
                                    "factor", rep("character", 2), rep("factor", 2),
                                    "integer", "factor", "numeric", "character"))
deployed <- deployed %>% 
              mutate(rel_ts = mdy_hms(paste(date, rel_time)),
                     date = mdy(date))

# Order merlins data set by release date/time
merlins$id_sorted <- factor(merlins$id, levels = as.character(deployed$id))

# Apply filter of release date/time for each individual
# The general (and I'm sure inefficient) approach here is to create a custom function
# that identifies the start date for a given individual
# This custom function is applied when creating a list of individuals histories from 
# the global data frame using the dlply function
# The data frame is then reassembled from this list

# First, define the function
clean_merl <- function(df) {
  merl_id <- unique(df$id)
  rel_dt <- filter(deployed, id == merl_id)$rel_ts
  clean_df <- df %>% filter(ts >= rel_dt)
  clean_df
}

# Separate individuals into list, applying filter
merl_list <- dlply(merlins, .(id_sorted), clean_merl)

# Reassemble filtered data frame, although we'll use the list
merlins <- ldply(merl_list)
```

``` {r create-overview-plots, echo=FALSE}
# Generate basic detection plot maps, if necessary
# These are generic maps that highlight the towers detecting
# a Merlin on a given day; detailed movement information is not displayed
if (!file.exists("./Output/Exploratory/2014_MERL_maps.pdf")) {

# Base point size
base_pt <- 3

# Load shapefiles to plot state boundaries and label state centroids
labels <- readOGR(dsn = "../GIS", layer = "state_labels")@data
sb <- suppressWarnings(readOGR(dsn = "../GIS", layer = "ec_lines_simple"))
sb <- fortify(sb)

# Couple of simple function to assist with label placement and point jitter
yrange = function(ggobj, panel) {ggplot_build(ggobj)$panel$ranges[[panel]]$y.range}
xrange = function(ggobj, panel) {ggplot_build(ggobj)$panel$ranges[[panel]]$x.range}

# Put maps into a list by tag ID
ids <- names(merl_list)
merl_maps <- vector("list", length(merl_list))
names(merl_maps) <- ids
for (merl in ids) {
  
  # Grab the data for a given Merlin
  dat <- merl_list[[merl]] %>% 
    
    # Clean it up and make a date label for each point
    mutate(lat = round(lat, 3),
           lon = round(lon, 3),
           date_label = factor(format(ts, "%d %b")))
  
  # Reorder levels of date label by actual date, not alphabetically
  dat$date_label <- reorder(dat$date_label, ymd(Left(dat$ts, 10)), mean)
  
  # Reduce to unique tower detections for a given day
  dat <- dat %>% group_by(id, r_ste, lat, lon, date_label) %>%
    select(id, r_ste, lat, lon, ts, date_label) %>%
    distinct(ts) %>%
    summarize(n = n(), 
              pt_mod = factor(floor(log(n, base=10)),
                              levels = 0:4,
                              labels = c("< 10", "10 - 100", "100 - 1K", "1K - 10K", "> 10K")))
  
  # Grab deployment data for this Merlin
  dat_deploy <- deployed %>% filter(id == merl) %>%
    # Add deployment date label and deployment location
    mutate(label = paste0("Deployed:\n", format(rel_ts, "%d %b"), " @ ", 
                          format(rel_ts, "%H:%M")),
           lat = 41.13,
           long = -71.535)
  
  test_map <- qmap(location = c(lon = -73.2, lat = 39.38),
         zoom = 7, maptype = "terrain")
  diff_x <- diff(xrange(test_map, 1))
  diff_y <- diff(yrange(test_map, 1))
  
  merl_maps[[merl]] <- 
    qmap(location = c(lon = -73.2, lat = 39.38),
         zoom = 7, maptype = "satellite") +
    # Add state boundaries and labels
    geom_path(data=sb, aes(x = long, y = lat, group = group), size=0.5,
              colour = "white") + 
    geom_text(data=labels, aes(label = State_abbr, x = POINT_X, y = POINT_Y),
              colour = "white", size=5) + 
    # Add deployment information
    geom_segment(data = dat_deploy, aes(x = long + diff_x/10, 
                                        y = lat - diff_y/10, 
                                        xend = long, 
                                        yend = lat), 
                 colour = "white",
                 arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
    geom_text(data = dat_deploy, aes(x = long + diff_x/10, 
                                     y = lat - diff_y/9, label = label), 
              colour = "white", vjust = 1, hjust = 0.5) +
    # Add detection information
    geom_point(data=dat, aes(x=lon, y=lat, fill=date_label), #, size = pt_mod), 
               pch=21, size = 4, colour="black", 
               position=position_jitter(h=diff_x/200, w=diff_y/200)) +
    scale_fill_brewer(paste("Merlin", merl, "- Fall 2014"), 
                      palette = "RdYlBu") +
#    scale_size_discrete("# detections", 
#                          range = c(base_pt, base_pt + 5),
#                          drop = FALSE) +
    theme(legend.justification=c(0,1), legend.position=c(0,1))
  }

ml <- do.call(marrangeGrob, c(merl_maps, list(nrow=1, ncol=1, top=NULL)))
ggsave("./Output/Exploratory/2014_MERL_maps.pdf", ml, 
       height=8, width=8)
}
```

```{r create_detection_history_plots, echo=FALSE}
if (!file.exists("./Output/Exploratory/2014_MERL_signal_plots.pdf")) {
  
  # Put maps into a list by tag ID
  ids <- names(merl_list)
  merl_plots <- vector("list", length(merl_list))
  names(merl_plots) <- ids
  for (falcon in ids) {
    
    # Grab the data for a given merl
    dat <- merl_list[[falcon]]
        
    # Grab deployment data for this merl
    dat_deploy <- deployed %>% filter(id == falcon)
    
    label <- paste("Deployed:", format(dat_deploy$rel_ts, "%d %b"), "@", 
                   format(dat_deploy$rel_ts, "%H:%M"))
    
    merl_plots[[falcon]] <- 
      ggplot(dat, aes(x = ts, y = dbm, group = site)) + 
      #geom_line(alpha=0.75) +
      geom_point(aes(fill = site), size = 4, pch = 21, alpha=0.5, colour = "gray20") +
      geom_text(aes(label = ant), hjust = 0.5, vjust = 0.5, size = 2) +
      scale_x_datetime("Date", #limits = c(dat_deploy$date, max(merlins$date)),
                       #breaks = date_breaks("hour"),
                       #minor_breaks = date_breaks("day"),
                       expand = c(0.01,0.01)) + #,
                       #labels = date_format("%b %d")) +
      scale_y_continuous("Signal strength (dbm)") + #, 
#                         limits = c(floor(min(merlins$dbm)), floor(max(merlins$dbm))),
#                         breaks = seq(floor(min(merlins$dbm)), floor(max(merlins$dbm)), 3)) +
      annotate_text(label, x=0, y=0, hjust=1) + 
      scale_fill_discrete("") +
      theme(legend.justification="center", legend.position=c(0.5,0.975), legend.direction = "horizontal") +
      ggtitle(paste("Merlin", falcon))
    
    # Add prettier axis labels (FOR DOWN THE ROAD)
#    p <- p + 
#      scale_x_datetime("Date", limits = c(dat_deploy$date, max(merlins$date)),
#                       breaks = date_breaks("1 day"),
#                       minor_breaks = NULL,
#                       expand = c(0.01,0.01),
#                       labels = insert_minor(range = xrange(p, 1, date = TRUE),
#                                             maj_div = "week", min_div = "1 day",
#                                             date = TRUE))
  
  }
  
  ml <- do.call(marrangeGrob, c(merl_plots, list(nrow=1, ncol=1, top=NULL)))
  ggsave("./Output/Exploratory/2014_MERL_signal_plots.pdf", ml, width=11, height=8.5)
}
```

```{r encounter, echo=FALSE}
# Load the filtered encounter data
# Raw encounter data contained 916 records (through 15 Jan 2015)
# 26 records discarded for various reasons, including:
#   - missing encounter location (n = 6)
#   - multiple recaptures that didn't provide additional information (n = 20), such as:
#       - multiple recaptures on breeding ground (n = 10)
#       - recaptures at or near same non-breeding location, close in time (n = 9)
#       - intermediate (migration) record omitted to leave winter-breeding connection (n = 1)
encounters <- convert.magic(read.csv("./Data/MERL_encounters.csv", header=TRUE),
                          types = c("character", "integer", rep("character", 4),
                                    rep("numeric", 2), "integer", rep("numeric", 2),
                                    "integer", rep("character", 2), rep("logical", 2)))

# Calculate and append the great circle distance and bearing of encounters
# At the moment this is not vectorized :(
n <- nrow(encounters)
gc <- data.frame(gcdist = rep(0, n), gcbear = rep(0, n))
for (i in 1:n) {
  dat <- encounters[i, ]
  dist <- round(with(dat, distVincentyEllipsoid(c(b_lon, b_lat),
                                                c(e_lon, e_lat)))/1000)
  bear <- round(with(dat, bearing(c(b_lon, b_lat), c(e_lon, e_lat))), 1)
  gc[i, ] <- c(dist, bear)
  }
encounters <- data.frame(encounters, gc)

# Remove encounters that contribute no movement information
# i.e., captured and recaptured at the same location
encounters <- subset(encounters, gcdist > 0) # 136 of 890 records

# Some variable conversion and characterization of the type of encounter
encounters <- encounters %>% 
              mutate(b_date = mdy(b_date),
                     e_date = mdy(e_date),
                     b_sex = factor(b_sex, levels = c("M", "F", "U")),
                     b_age = factor(b_age, levels = c("HY", "AHY", "U")),
                     same_yr = ifelse(year(b_date) == year(e_date), TRUE, FALSE),
                     # attempt to classify encounters
                     type = factor(ifelse(month(b_date) %in% 5:8 & month(e_date) %in% 5:8, "breeding",
                            ifelse(month(b_date) %in% 9:10 & month(e_date) %in% 9:10, "fall migration",
                            ifelse(month(b_date) %in% 3:4 & month(e_date) %in% 3:4, "spring migration",
                            ifelse(month(b_date) %in% c(11:12,1:2) & month(e_date) %in% c(11:12,1:2), "winter",
                                   
                            ifelse(month(b_date) %in% 5:8 & month(e_date) %in% c(11:12,1:2), "breeding-winter",
                            ifelse(month(b_date) %in% c(11:12,1:2) & month(e_date) %in% 5:8, "breeding-winter",
                            ifelse(month(b_date) %in% 5:8 & month(e_date) %in% 3:4, "breeding-migration",
                            ifelse(month(b_date) %in% 3:4 & month(e_date) %in% 5:8, "breeding-migration",
                            ifelse(month(b_date) %in% 9:10 & month(e_date) %in% 5:8, "breeding-migration",
                            ifelse(month(b_date) %in% 5:8 & month(e_date) %in% 9:10, "breeding-migration",
                            ifelse(month(b_date) %in% 9:10 & month(e_date) %in% 3:4, "spring-fall migrations",
                            ifelse(month(b_date) %in% 3:4 & month(e_date) %in% 9:10, "spring-fall migrations",
                                   "winter-migration"))))))))))))))
                                   
# Heat map of encounters by banding month and encounter month
enc_heat <- ddply(encounters, .(month(b_date), month(e_date)), nrow)
# The following four lines were used to check validity of encounter 'type' assignments
# e.g., by creating a heat map for each 'type' subset
#enc_type <- "breeding"
#test <- subset(encounters, type == enc_type)
#cat("# records of encounter type:", enc_type, "---", nrow(test))
#enc_heat <- ddply(test, .(month(b_date), month(e_date)), nrow)

names(enc_heat) = c("band_mo", "encounter_mo", "count")
ggplot(enc_heat, aes(y = encounter_mo, x = band_mo)) + 
  geom_tile(aes(fill=count)) +
  scale_fill_gradient(limits = c(1, max(enc_heat$count)), low = "blue", high = "red") + 
  scale_x_continuous("Month banded", breaks = 1:12) + 
  scale_y_continuous("Month encountered", breaks = 1:12)

# Test plot
flyway <- readOGR(dsn = "../GIS", layer = "US_Atl_Coast")
banded <- SpatialPointsDataFrame(encounters[, c("b_lon", "b_lat")], encounters, coords.nrs = c(8,7),
                                 proj4string = flyway@proj4string)
atl_bands <- which(!is.na(over(banded, flyway)))
recoved <- SpatialPointsDataFrame(encounters[, c("e_lon", "e_lat")], encounters, coords.nrs = c(8,7),
                                 proj4string = flyway@proj4string)
atl_recovs <- which(!is.na(over(recoved, flyway)))
atl_recs <- unique(c(atl_bands, atl_recovs))

# Atlantic Coast (within 250 km of US Atlantic Coast) encounters
atl_encounters <- encounters[atl_recs, ]

# Get rid of winter-winter recoveries; limited movement information
# Reformat encounter type for nicer plotting
atl_encounters <- droplevels(subset(atl_encounters, type != "winter")) # 346 records
levels(atl_encounters$type) <- list(breeding = c("breeding-migration", "breeding-winter"),
                                    winter = "winter-migration",
                                    migration = c("fall migration", "spring-fall migrations"))

# Histrograms of recovery distance by encounter type
ggplot(atl_encounters, aes(x = gcdist)) + geom_histogram() + facet_wrap(~ type)

# Atlantice Coast recovery overview

# Get country and world boundaries
westhemi <- readOGR("../GIS", "western_hemisphere")
westhemi <- fortify(westhemi)
USCANMEX <- readOGR("../GIS", "USCANMEX")
USCANMEX <- fortify(USCANMEX)

encounter_map <- 
  qmap(location = c(lon = -75, lat = 33.8), zoom = 4,
#  qmap(location = c(lon = -96, lat = 39), zoom = 3,
       maptype = "satellite") +
# Subset by encounter first?
#  geom_segment(data = subset(atl_encounters, type == "migration"),
  geom_segment(data = atl_encounters,
               aes(x = b_lon, xend = e_lon, 
                   y = b_lat, yend = e_lat,
                   colour = type),
               size = 1.25, alpha = 0.5) +
  scale_colour_manual("Encounter type", values = c("#00ff00", "#ff0000", "#ffff00"),
                      drop = FALSE,
                      guide = guide_legend(override.aes = list(alpha = 1))) +
  theme(legend.position=c(0,1), legend.justification=c(0,1),
        legend.title = element_text(size=22, color = "white", face = "bold"),
        legend.text = element_text(size=18, color = "white", face = "bold"),
        legend.background = element_blank(), legend.key = element_blank(),
        legend.key.width = unit(0.05, "npc")) +
  geom_path(data=USCANMEX, aes(x=long, y=lat, group=group), color = "white", alpha = 0.25) +
  geom_path(data=westhemi, aes(x=long, y=lat, group=group), color = "white", alpha = 0.75)  
encounter_map

```
